from __future__ import annotations
from aiofile import async_open
from datetime import datetime
import asyncio
import logging
import asyncpg
from dotenv import load_dotenv
import json
import os
from time import perf_counter
from typing import Annotated
from livekit import rtc, api
from livekit.agents import (
    AutoSubscribe,
    JobContext,
    JobProcess,
    WorkerOptions,
    cli,
    llm,
)
from asyncpg import create_pool
from livekit.agents.multimodal import MultimodalAgent
from livekit.agents.pipeline import VoicePipelineAgent
from livekit.plugins import deepgram, openai, silero
from typing import Optional
from livekit.plugins.deepgram import tts
import pandas as pd







# load environment variables, this is optional, only used for local development
load_dotenv(dotenv_path=".env.local")
os.environ["OPENAI_API_KEY"]=" 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"

logger = logging.getLogger("outbound-caller")
logger.setLevel(logging.INFO)

outbound_trunk_id = os.getenv("SIP_OUTBOUND_TRUNK_ID")

async def entrypoint(ctx: JobContext):
    
    global _default_instructions, outbound_trunk_id
    logger.info(f"connecting to room {ctx.room.name}")
    await ctx.connect(auto_subscribe=AutoSubscribe.AUDIO_ONLY)

    user_identity = "phone_user"
    # the phone number to dial is provided in the job metadata
    phone_number = ctx.job.metadata
    phone_number = ctx.job.metadata
    
    
   
   

    # look up the user's phone number and appointment details
    instructions = (
        f"You are cold caller advertiser  for a clothing company called Powerlook"
        f"You have to advertise the discount for Republic Day where there is 15% discount above 1500rs shopping"
        f"You have to speak in English"
        f"You have to be a entertaining advertiser and make complitments to the user so that he will want to talk to u more "
        f"give remark of the call using function calling  before ending the call"
        "make sure to update_call_status using function calling before ending the call"
    )

    # `create_sip_participant` starts dialing the user
    await ctx.api.sip.create_sip_participant(
        api.CreateSIPParticipantRequest(
            room_name=ctx.room.name,
            sip_trunk_id=outbound_trunk_id,
            sip_call_to=phone_number,
            participant_identity=user_identity,
        )
    )

    # a participant is created as soon as we start dialing
    participant = await ctx.wait_for_participant(identity=user_identity)

    # start the agent, either a VoicePipelineAgent or MultimodalAgent
    # this can be started before the user picks up. The agent will only start
    # speaking once the user answers the call.
    # run_voice_pipeline_agent(ctx, participant, instructions)
    run_voice_pipeline_agent(ctx, participant, instructions)

    # in addition, you can monitor the call status separately
    start_time = perf_counter()
    while perf_counter() - start_time < 30:
        call_status = participant.attributes.get("sip.callStatus")
        if call_status == "active":
            logger.info("user has picked up")
            return
        elif call_status == "automation":
            # if DTMF is used in the `sip_call_to` number, typically used to dial
            # an extension or enter a PIN.
            # during DTMF dialing, the participant will be in the "automation" state
            pass
        elif participant.disconnect_reason == rtc.DisconnectReason.USER_REJECTED:
            logger.info("user rejected the call, exiting job")
            break
        elif participant.disconnect_reason == rtc.DisconnectReason.USER_UNAVAILABLE:
            logger.info("user did not pick up, exiting job")
            break
        await asyncio.sleep(0.1)

    logger.info("session timed out, exiting job")
    ctx.shutdown()


class CallActions(llm.FunctionContext):
    """
    Detect user intent and perform actions
    """

    def __init__(
        self, *, api: api.LiveKitAPI, participant: rtc.RemoteParticipant, room: rtc.Room,phone_number
    ):
        super().__init__()

        self.api = api
        self.participant = participant
        self.room = room
        self.phone_number=phone_number

    async def hangup(self):
        try:
            await self.api.room.remove_participant(
                api.RoomParticipantIdentity(
                    room=self.room.name,
                    identity=self.participant.identity,
                )
            )
        except Exception as e:
            # it's possible that the user has already hung up, this error can be ignored
            logger.info(f"received error while ending call: {e}")
   
    def update_call_status(self,phone_number, file_path='data.csv'):
        try:
            # Load the CSV file into a DataFrame
            df = pd.read_csv(file_path)

            # Find the row where the Name matches the customer_name
            if phone_number in df['Phone Number'].values:
                # Update the 'Call Status' to 'called' for the matched row
                df.loc[df['Phone Number'] == self.phone_number, 'Call Status'] = 'called'
                
                # Save the updated DataFrame back to the CSV file
                df.to_csv(file_path, index=False)
                print(f"Call status updated to 'called' for {self.phone_number}.")
                return "success"
            else:
                print(f"Customer {self.phone_number} not found in the data.")
        except FileNotFoundError:
            print(f"Error: The file {file_path} does not exist.")
        except Exception as e:
            print(f"An error occurred: {e}")
            
    def update_remarks(self,phone_number, remark, file_path='data.csv'):
        try:
            # Load the CSV file into a DataFrame
            df = pd.read_csv(file_path)

            # Find the row where the Name matches the customer_name
            if phone_number in df['Phone Number'].values:
                # Update the 'Remarks' column for the matched row
                df.loc[df['Phone Number'] == phone_number, 'Remarks'] = remark
                
                # Save the updated DataFrame back to the CSV file
                df.to_csv(file_path, index=False)
                print(f"Remark added for {phone_number}.")
                return "success"
            else:
                print(f"Customer {phone_number} not found in the data.")
        
        except FileNotFoundError:
            print(f"Error: The file {file_path} does not exist.")
        except Exception as e:
            print(f"An error occurred: {e}")
    def update_callback(self,phone_number, callback_date, file_path='data.csv'):
        try:
            # Load the CSV file into a DataFrame
            df = pd.read_csv(file_path)

            # Find the row where the Name matches the customer_name
            if phone_number in df['Phone Number'].values:
                # Update the 'Next Follow-up Date' column for the matched row
                df.loc[df['Phone Number'] == phone_number, 'Next Follow-up Date'] = callback_date
                
                # Save the updated DataFrame back to the CSV file
                df.to_csv(file_path, index=False)
                print(f"Callback date added for {phone_number}.")
                return "success"
            else:
                print(f"Customer {phone_number} not found in the data.")
        
        except FileNotFoundError:
            print(f"Error: The file {file_path} does not exist.")
        except Exception as e:
            print(f"An error occurred: {e}")

   

    @llm.ai_callable()
    async def end_call(self):
        """Called when the user wants to end the call"""
        logger.info(f"ending the call for {self.phone_number}")
        await self.hangup()

    # @llm.ai_callable()
    # async def search_knowledge_base(self, query: Annotated[str, "Query to search in the knowledge base the question user is asking on the call you want to check"]):
    #     """Called to search the knowledge base for user queries."""
    #     logger.info(f"Searching knowledge base for query: {query}")
        
    #     # Read the knowledge base from the file
    #     solution = resolve_db(query)
    #     # Simulate a search by checking if any knowledge base entry matches the complain
    #     return str(solution)
    
    @llm.ai_callable()
    def update_status(self,customer_name:Annotated[str,"The name of the customer initially provided in the instructions"]):
        """Call this to update the call status of the customer. Always do this before ending the call."""
        logger.info(f"Updating the call status of {self.participant.identity}")
        result=self.update_call_status(self.phone_number)
        if result=="success":
         return "call status has been updated"
    
    @llm.ai_callable()
    async def add_remark(self,customer_name:Annotated[str,"The name of the customer initially provided in the instructions"],remark:Annotated[str,"The review of the call how was the experience how was the customer"]):
        """Call this function always before ending the call to give a review of the call"""
        logger.info(f"Updating the call status of {self.participant.identity}")
        result=self.update_remarks(self.phone_number,remark)
        if result=="success":
         return "call status has been updated"
    
    @llm.ai_callable()
    async def add_callback(self,customer_name:Annotated[str,"The name of the customer initially provided in the instructions"],callback_date:Annotated[str,"The date when the customer wants you to callback"]):
        """Call this function when the user is busy or wants to talk some other time ask him the preferred date and time"""
        logger.info(f"Adding a callback for {self.participant.identity}")
        result= self.update_callback(self.phone_number,callback_date)
        if result=="success":
         return "callback date has been added"


    @llm.ai_callable()
    async def detected_answering_machine(self):
        """Called when the call reaches voicemail. Use this tool AFTER you hear the voicemail greeting"""
        logger.info(f"detected answering machine for {self.participant.identity}")
        await self.hangup()

    @llm.ai_callable()
    async def offer_sale_details(self):
        """Called when the user asks for more details about the sale"""
        logger.info(f"Offering sale details to {self.participant.identity}")
        return "Our sale includes discounts on dresses, shirts, pants, and accessories. You can save up to 50% off on selected items. Hurry, the sale is for a limited time only!"
                    
    @llm.ai_callable()
    async def thank_user(self):
        """Called to thank the user for their time"""
        logger.info(f"Thanking {self.participant.identity}")
        return "Thank you for your time! We hope to see you soon in our store. Have a great day!"
    
    # @llm.ai_callable()
    # async def send_whatsapp(self):
    #     """Called to send the sale details to user through whatsapp"""
    #     logger.info(f"Sending sale details to {self.participant.identity}")
    #     print(self.participant.identity)
    #     result=send_whatsapp(self.phone_number)
    #     if result=="success":
    #         logging.info(f"the details have been sent to {self.phone_number}")
    #         return "The details have been sent to {self.participant.identity"
    #     else:
    #         return "could not send the details to {self.phone_number}"
                
        
    


def run_voice_pipeline_agent(
    ctx: JobContext, participant: rtc.RemoteParticipant, instructions: str
):
    logger.info("starting voice pipeline agent")

    initial_ctx = llm.ChatContext().append(
        role="system",
        text=instructions,
    )

    agent = VoicePipelineAgent(
        vad=ctx.proc.userdata["vad"],
        stt=deepgram.STT(model="nova-2-phonecall",api_key=os.getenv("DEEPGAM_API_KEY")),
        llm=openai.LLM(model="gpt-4o-mini"),
        tts=tts.TTS(model="aura-asteria-en"),
        chat_ctx=initial_ctx,
        fnc_ctx=CallActions(api=ctx.api, participant=participant, room=ctx.room,phone_number=ctx.job.metadata),
    )

    agent.start(ctx.room, participant)


def run_multimodal_agent(
    ctx: JobContext, participant: rtc.RemoteParticipant, instructions: str
):
    logger.info("starting multimodal agent")

    model = openai.realtime.RealtimeModel(
        instructions=instructions,
        modalities=["audio", "text"],
    )
    agent = MultimodalAgent(
        model=model,
        fnc_ctx=CallActions(api=ctx.api, participant=participant, room=ctx.room),
    )
    agent.start(ctx.room, participant)


def prewarm(proc: JobProcess):
    proc.userdata["vad"] = silero.VAD.load()


if __name__ == "__main__":
    if not outbound_trunk_id or not outbound_trunk_id.startswith("ST_"):
        raise ValueError(
            "SIP_OUTBOUND_TRUNK_ID is not set. Please follow the guide at https://docs.livekit.io/agents/quickstarts/outbound-calls/ to set it up."
        )
    cli.run_app(
        WorkerOptions(
            entrypoint_fnc=entrypoint,
            # giving this agent a name will allow us to dispatch it via API
            # automatic dispatch is disabled when `agent_name` is set
            agent_name="outbound-caller",
            # prewarm by loading the VAD model, needed only for VoicePipelineAgent
            prewarm_fnc=prewarm,
        )
    )
